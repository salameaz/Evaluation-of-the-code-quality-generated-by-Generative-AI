Question Number,prompt,human_generated_code,CHATGPT,COPILOT,difficulty
4,"class Solution:
    def maxSum(self, nums: List[int]) -> int:
""""""You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.

Return the maximum sum or -1 if no such pair exists.

Example 1:

Input: nums = [51,71,17,24,42]
Output: 88
Explanation: 
For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. 
For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.
It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.

Example 2:

Input: nums = [1,2,3,4]
Output: -1
Explanation: No pair exists in nums with equal maximum digits.

Constraints:

2 <= nums.length <= 100
1 <= nums[i] <= 10^4""""""","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum","from typing import List
from collections import defaultdict

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        # Function to find the maximum digit in a number
        def max_digit(n):
            return max(int(d) for d in str(n))
        
        # Dictionary to group numbers by their maximum digit
        max_digit_dict = defaultdict(list)
        
        # Populate the dictionary
        for num in nums:
            digit = max_digit(num)
            max_digit_dict[digit].append(num)
        
        # Variable to track the maximum sum of pairs
        max_sum = -1
        
        # Iterate through the dictionary to find the maximum sum
        for digit, group in max_digit_dict.items():
            if len(group) > 1:
                group.sort(reverse=True)
                current_sum = group[0] + group[1]
                max_sum = max(max_sum, current_sum)
        
        return max_sum

# Example usage
solution = Solution()
print(solution.maxSum([51, 71, 17, 24, 42]))  # Output: 88
print(solution.maxSum([1, 2, 3]))","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_digit = {}  # Dictionary to store maximum digit for each number

        # Iterate through the array and update max_digit
        for num in nums:
            max_digit[num] = max(max_digit.get(num, 0), max(str(num)))

        max_sum = -1  # Initialize max_sum to -1

        # Check for pairs with equal maximum digits
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if max_digit[nums[i]] == max_digit[nums[j]]:
                    max_sum = max(max_sum, nums[i] + nums[j])

        return max_sum",easy
5,"class Solution:
    def finalString(self, s: str) -> str:
""""""You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.

Return the final string that will be present on your laptop screen.

Example 1:

Input: s = ""string""
Output: ""rtsng""
Explanation: 
After typing first character, the text on the screen is ""s"".
After the second character, the text is ""st"". 
After the third character, the text is ""str"".
Since the fourth character is an 'i', the text gets reversed and becomes ""rts"".
After the fifth character, the text is ""rtsn"". 
After the sixth character, the text is ""rtsng"". 
Therefore, we return ""rtsng"".

Example 2:

Input: s = ""poiinter""
Output: ""ponter""
Explanation: 
After the first character, the text on the screen is ""p"".
After the second character, the text is ""po"". 
Since the third character you type is an 'i', the text gets reversed and becomes ""op"". 
Since the fourth character you type is an 'i', the text gets reversed and becomes ""po"".
After the fifth character, the text is ""pon"".
After the sixth character, the text is ""pont"". 
After the seventh character, the text is ""ponte"". 
After the eighth character, the text is ""ponter"". 
Therefore, we return ""ponter"".
 
Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.
s[0] != 'i'
""""""","class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s","class Solution:
    def finalString(self, s: str) -> str:
        screen_text = []
        
        for char in s:
            if char == 'i':
                screen_text.reverse()
            else:
                screen_text.append(char)
        
        return ''.join(screen_text)

# Example usage:
solution = Solution()
print(solution.finalString(""string""))  # Output: ""rtsng""
print(solution.finalString(""poiinter""))  # Output: ""ponter""","class Solution:
    def finalString(self, s: str) -> str:
        screen_text = []
        
        for char in s:
            if char == 'i':
                screen_text.reverse()
            else:
                screen_text.append(char)
        
        return ''.join(screen_text)

# Example usage:
solution = Solution()
print(solution.finalString(""string""))  # Output: ""rtsng""
print(solution.finalString(""poiinter""))  # Output: ""ponter""",easy
6,"prompt = """"""
You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.

Return the maximum sum or -1 if no such pair exists.

Example 1:

Input: nums = [51,71,17,24,42]
Output: 88
Explanation: 
For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. 
For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.
It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.

Example 2:

Input: nums = [1,2,3,4]
Output: -1
Explanation: No pair exists in nums with equal maximum digits.

Constraints:

2 <= nums.length <= 100
1 <= nums[i] <= 10^4

class Solution:
    def maxSum (self, nums: List[int]) -> int:
""""""","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum","from typing import List
from collections import defaultdict

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        # Helper function to find the maximum digit in a number
        def max_digit(num):
            return max(int(d) for d in str(num))

        # Dictionary to store numbers grouped by their maximum digit
        max_digit_map = defaultdict(list)

        # Populate the dictionary
        for num in nums:
            digit = max_digit(num)
            max_digit_map[digit].append(num)

        # Initialize the result to -1 (no valid pairs found yet)
        max_pair_sum = -1

        # Iterate through the groups in the dictionary
        for digit, group in max_digit_map.items():
            if len(group) >= 2:
                # Sort the group in descending order to find the largest pair
                group.sort(reverse=True)
                # Calculate the pair sum of the two largest numbers
                max_pair_sum = max(max_pair_sum, group[0] + group[1])

        return max_pair_sum

# Example usage
solution = Solution()
nums = [51, 71, 17, 24, 42]
print(solution.maxSum(nums))  # Should return 88 (51 + 42 or 71 + 17)","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_digit_sum = [-1] * 10

        for num in nums:
            max_digit = max(str(num))
            max_digit_sum[int(max_digit)] = max(max_digit_sum[int(max_digit)], num)

        result = -1
        for num in nums:
            max_digit = max(str(num))
            if max_digit_sum[int(max_digit)] != -1:
                result = max(result, num + max_digit_sum[int(max_digit)])

        return result",easy
7,"prompt = """"""
class Solution:
    def finalString(self, s: str) -> str:

Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.

You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.

Return the final string that will be present on your laptop screen.

Example 1:

Input: s = ""string""
Output: ""rtsng""

Example 2:

Input: s = ""poiinter""
Output: ""ponter""
 
Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.
s[0] != 'i'
""""""","class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s","class Solution:
    def finalString(self, s: str) -> str:
        result = []
        
        for char in s:
            if char == 'i':
                result.reverse()
            else:
                result.append(char)
        
        return ''.join(result)

# Example usage:
sol = Solution()
print(sol.finalString(""string""))  # Output: ""rtsng""
print(sol.finalString(""poiinter""))  # Output: ""ponter""","class Solution:
    def finalString(self, s: str) -> str:
        final_chars = []  # Initialize an empty list for the final characters
        for char in s:
            if char != 'i':
                final_chars.append(char)  # Append non-'i' characters
            else:
                final_chars.reverse()  # Reverse the list for 'i'
        return ''.join(final_chars)  # Join the characters to form the final string

# Example usage:
solution = Solution()
print(solution.finalString(""string""))  # Output: ""rtsng""
print(solution.finalString(""poiinter""))  # Output: ""ponter""",easy
8,"""""""You are given a 0-indexed integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the maximum digit in both numbers are equal.

Return the maximum sum or -1 if no such pair exists.

Example 1:

Input: nums = [51,71,17,24,42]
Output: 88
Explanation: 
For i = 1 and j = 2, nums[i] and nums[j] have equal maximum digits with a pair sum of 71 + 17 = 88. 
For i = 3 and j = 4, nums[i] and nums[j] have equal maximum digits with a pair sum of 24 + 42 = 66.
It can be shown that there are no other pairs with equal maximum digits, so the answer is 88.

Example 2:

Input: nums = [1,2,3,4]
Output: -1
Explanation: No pair exists in nums with equal maximum digits.
 
Constraints:

2 <= nums.length <= 100
1 <= nums[i] <= 10^4""""""

class Solution:
    def maxSum(self, nums: List[int]) -> int:","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        max_by_digit = defaultdict(int)
        max_sum = -1

        for num in nums:
            digit = max(str(num))

            if digit in max_by_digit:
                max_sum = max(max_sum, max_by_digit[digit] + num)

            max_by_digit[digit] = max(max_by_digit[digit], num)

        return max_sum","from typing import List
from collections import defaultdict

class Solution:
    def maxSum(self, nums: List[int]) -> int:
        def max_digit(n):
            """""" Helper function to find the maximum digit in a number """"""
            return max(map(int, str(n)))

        # Dictionary to store lists of numbers grouped by their maximum digit
        digit_groups = defaultdict(list)

        for num in nums:
            digit = max_digit(num)
            digit_groups[digit].append(num)

        max_sum = -1

        # Iterate over each group to find the maximum pair sum
        for numbers in digit_groups.values():
            if len(numbers) > 1:
                # Sort the numbers in descending order
                numbers.sort(reverse=True)
                # Take the sum of the two largest numbers
                current_sum = numbers[0] + numbers[1]
                # Update max_sum if we found a new maximum
                max_sum = max(max_sum, current_sum)

        return max_sum

# Example usage
solution = Solution()

# Example 1
nums1 = [51, 71, 17, 24, 42]
print(""Example 1 Result:"", solution.maxSum(nums1))  # Expected output: 93 (51 + 42)

# Example 2
nums2 = [123, 456, 789, 12, 34, 56]
print(""Example 2 Result:"", solution.maxSum(nums2))  # Expected output: 745 (456 + 789)

# Example 3
nums3 = [9, 8, 7, 6, 5, 4, 3, 2, 1]
print(""Example 3 Result:"", solution.maxSum(nums3))  # Expected output: 15 (8 + 7)

# Example 4
nums4 = [10, 20, 30, 40, 50]
print(""Example 4 Result:"", solution.maxSum(nums4))  # Expected output: -1 (no pair with sam","class Solution:
    def maxSum(self, nums: List[int]) -> int:
        # Initialize a dictionary to store numbers by their maximum digit
        max_digit_dict = {}
        
        # Populate the dictionary
        for num in nums:
            max_digit = max(str(num))  # Get the maximum digit
            if max_digit not in max_digit_dict:
                max_digit_dict[max_digit] = []
            max_digit_dict[max_digit].append(num)
        
        # Sort the lists of numbers for each maximum digit
        for max_digit in max_digit_dict:
            max_digit_dict[max_digit].sort(reverse=True)
        
        # Check if there are at least two numbers with the same maximum digit
        for max_digit in max_digit_dict:
            if len(max_digit_dict[max_digit]) >= 2:
                return max_digit_dict[max_digit][0] + max_digit_dict[max_digit][1]
        
        # If no such pair exists, return -1
        return -1",easy
9,"""""""Your laptop keyboard is faulty, and whenever you type a character 'i' on it, it reverses the string that you have written. Typing other characters works as expected.

You are given a 0-indexed string s, and you type each character of s using your faulty keyboard.

Return the final string that will be present on your laptop screen.

Example 1:

Input: s = ""string""
Output: ""rtsng""
Explanation: 
After typing first character, the text on the screen is ""s"".
After the second character, the text is ""st"". 
After the third character, the text is ""str"".
Since the fourth character is an 'i', the text gets reversed and becomes ""rts"".
After the fifth character, the text is ""rtsn"". 
After the sixth character, the text is ""rtsng"". 
Therefore, we return ""rtsng"".

Example 2:

Input: s = ""poiinter""
Output: ""ponter""
Explanation: 
After the first character, the text on the screen is ""p"".
After the second character, the text is ""po"". 
Since the third character you type is an 'i', the text gets reversed and becomes ""op"". 
Since the fourth character you type is an 'i', the text gets reversed and becomes ""po"".
After the fifth character, the text is ""pon"".
After the sixth character, the text is ""pont"". 
After the seventh character, the text is ""ponte"". 
After the eighth character, the text is ""ponter"". 
Therefore, we return ""ponter"".
 
Constraints:

1 <= s.length <= 100
s consists of lowercase English letters.
s[0] != 'i'""""""
class Solution:
    def finalString(self, s: str) -> str:","class Solution:
    def finalString(self, s: str) -> str:
        while ""i"" in s:
            index=s.index(""i"")

            #first half and second half
            first=s[:index][::-1]
            second=s[index+1:]

            s="""".join([first,second])
        return s","class Solution:
    def finalString(self, s: str) -> str:
        result = []
        for char in s:
            if char == 'i':
                result.reverse()
            else:
                result.append(char)
        return ''.join(result)

# Example usage
sol = Solution()
print(sol.finalString(""string""))  # Output: ""rtsng""
print(sol.finalString(""poiinter""))  # Output: ""ponter""","class Solution:
    def finalString(self, s: str) -> str:
        stack = []
        for char in s:
            if char == 'i':
                if stack:
                    stack.pop()
            else:
                stack.append(char)
        return ''.join(stack)",easy
13,"Solve the following problem with python3 code. Class name: Solution, Method name: def findMaximumElegance(self, items: List[List[int]], k: int) -> int:.

You are given a 0-indexed 2D integer array items of length n and an integer k.

items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.

Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.

Your task is to find the maximum elegance from all subsequences of size k in items.

Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.

Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.

Example 1:

Input: items = [[3,2],[5,1],[10,1]], k = 2
Output: 17
Explanation: In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. 
  
 
Constraints:

1 <= items.length == n <= 10^5
items[i].length == 2
items[i][0] == profit_i
items[i][1] == category_i
1 <= profit_i <= 10^9
1 <= category_i <= n 
1 <= k <= n","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res solution = Solution()
items = [[3, 2], [5, 1], [10, 1]]
k = 2
print(""Result:"", solution.findMaximumElegance(items, k))  # Expected output: 17 (10+5 + 1^2)","from collections import defaultdict
from typing import List

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Step 1: Sort items by profit in descending order
        items.sort(reverse=True, key=lambda x: x[0])
        
        # Step 2: Select the top k items
        selected_items = items[:k]
        remaining_items = items[k:]
        
        # Calculate the initial total profit and count of distinct categories
        total_profit = sum(item[0] for item in selected_items)
        category_count = defaultdict(int)
        for item in selected_items:
            category_count[item[1]] += 1
        
        distinct_categories = len(category_count)
        max_elegance = total_profit + distinct_categories ** 2
        
        # Step 3: Try to optimize by swapping items to get more distinct categories
        extra_items = sorted(remaining_items, reverse=True, key=lambda x: x[0])
        
        for i in range(k):
            for j in range(len(extra_items)):
                current_item = selected_items[i]
                new_item = extra_items[j]
                
                # Skip if the new item is from the same category as the current item
                if current_item[1] == new_item[1]:
                    continue
                
                # Calculate the potential new elegance if we swap these items
                new_total_profit = total_profit - current_item[0] + new_item[0]
                
                # Adjust category counts for the swap
                new_category_count = category_count.copy()
                new_category_count[current_item[1]] -= 1
                if new_category_count[current_item[1]] == 0:
                    del new_category_count[current_item[1]]
                
                new_category_count[new_item[1]] += 1
                new_distinct_categories = len(new_category_count)
                
                new_elegance = new_total_profit + new_distinct_categories ** 2
                
                # Update max_elegance if this swap is better
                if new_elegance > max_elegance:
                    max_elegance = new_elegance
                    total_profit = new_total_profit
                    category_count = new_category_count
                    selected_items[i] = new_item
                    extra_items[j] = current_item
        
        return max_elegance        solution = Solution()
items = [[3, 2], [5, 1], [10, 1]]
k = 2
print(""Result:"", solution.findMaximumElegance(items, k))  # Expected output: 17 (10+5 + 1^2)","from typing import List

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Sort items by profit in descending order
        items.sort(key=lambda x: x[0], reverse=True)
        
        total_profit = 0
        distinct_categories = set()
        max_elegance = 0
        
        for profit, category in items:
            total_profit += profit
            distinct_categories.add(category)
            
            if len(distinct_categories) == k:
                # Calculate elegance for the current subsequence
                elegance = total_profit + len(distinct_categories) ** 2
                max_elegance = max(max_elegance, elegance)
                
        return max_elegance",hard
14,"You are given an array nums of n positive integers and an integer k.

Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:

Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.
Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.
Multiply your score by x.
Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.

The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.

Return the maximum possible score after applying at most k operations.

Since the answer may be large, return it modulo 10^9 + 7.

Example 1:

Input: nums = [8,3,9,3,8], k = 2
Output: 81
Explanation: To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.

Example 2:

Input: nums = [19,12,14,6,10,18], k = 3
Output: 4788
Explanation: To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
 
Constraints:

1 <= nums.length == n <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= min(n * (n + 1) / 2, 10^9)""""""
class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:","class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res","from typing import List
import math
from collections import defaultdict

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        
        # Step 1: Function to calculate the prime score of a number
        def prime_score(x):
            factors = set()
            d = 2
            while d * d <= x:
                while (x % d) == 0:
                    factors.add(d)
                    x //= d
                d += 1
            if x > 1:
                factors.add(x)
            return len(factors)
        
        n = len(nums)
        
        # Calculate prime scores for all numbers in nums
        prime_scores = [prime_score(num) for num in nums]
        
        # Step 2: We need to keep track of the maximum prime score subarray elements
        elements = []
        
        for i in range(n):
            for j in range(i, n):
                subarray_max_prime_score = 0
                best_element = -1
                best_index = -1
                for l in range(i, j + 1):
                    if prime_scores[l] > subarray_max_prime_score or (prime_scores[l] == subarray_max_prime_score and best_index == -1):
                        subarray_max_prime_score = prime_scores[l]
                        best_element = nums[l]
                        best_index = l
                elements.append(best_element)
        
        # Step 3: Sort the elements by prime score and index
        elements = list(set(elements))
        elements.sort(key=lambda x: (-prime_scores[nums.index(x)], nums.index(x)))
        
        # Step 4: Select the top k elements
        score = 1
        for i in range(min(k, len(elements))):
            score = (score * elements[i]) % MOD
        
        return score

# Example usage:
solution = Solution()
print(solution.maximumScore([8, 3, 9, 3, 8], 2))  # Output: 81
print(solution.maximumScore([19, 12, 14, 6, 10, 18], 3))  # Output: 4788","def maxScore(nums, k):
    MOD = 10**9 + 7
    n = len(nums)
    
    # Initialize dp array
    dp = [[0] * (k + 1) for _ in range(n)]
    
    # Base case: dp[i][0] = 1 for all i (initial score is 1)
    for i in range(n):
        dp[i][0] = 1
    
    # Calculate dp[i][j] for 1 <= j <= k
    for i in range(n):
        for j in range(1, k + 1):
            # Initialize the maximum score for the current element
            max_score = 0
            
            # Iterate through all possible subarrays ending at index i
            for l in range(i, -1, -1):
                # Update max_score based on the prime score of nums[l, ..., i]
                prime_score = len(set(prime_factors(nums[l:i+1])))
                max_score = max(max_score, dp[l][j - 1] * nums[i] * prime_score)
                
            # Update dp[i][j]
            dp[i][j] = max(dp[i][j], max_score)
    
    # Return the maximum score using all elements and applying the operation at most k times
    return max(dp[-1]) % MOD

def prime_factors(num):
    factors = set()
    while num % 2 == 0:
        factors.add(2)
        num //= 2
    for i in range(3, int(num**0.5) + 1, 2):
        while num % i == 0:
            factors.add(i)
            num //= i
    if num > 2:
        factors.add(num)
    return factors

# Example usage
nums1 = [8, 3, 9, 3, 8]
k1 = 2
print(maxScore(nums1, k1))  # Output: 81

nums2 = [19, 12, 14, 6, 10, 18]
k2 = 3
print(maxScore(nums2, k2))  # Output: 4788",hard
15,"""""""You are given a 0-indexed 2D integer array items of length n and an integer k.

items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.

Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.

Your task is to find the maximum elegance from all subsequences of size k in items.

Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.

Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.

Example 1:

Input: items = [[3,2],[5,1],[10,1]], k = 2
Output: 17
Explanation: In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. 

Example 2:

Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
Output: 19
Explanation: In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.

Constraints:

1 <= items.length == n <= 10^5
items[i].length == 2
items[i][0] == profit_i
items[i][1] == category_i
1 <= profit_i <= 10^9
1 <= category_i <= n 
1 <= k <= n""""""
class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res","class Solution:
    def findMaximumElegance(self, items, k):
        from collections import defaultdict
        import heapq

        # Sort items by profit in descending order
        items.sort(reverse=True, key=lambda x: x[0])
        
        # Initial selection of top k items
        selected = items[:k]
        remaining = items[k:]

        # Calculate initial total profit and distinct categories
        total_profit = sum(item[0] for item in selected)
        category_count = defaultdict(int)
        for item in selected:
            category_count[item[1]] += 1

        distinct_categories = len(category_count)
        max_elegance = total_profit + distinct_categories**2

        # Min-heap to track the least profitable redundant items
        redundant = []
        for item in selected:
            if category_count[item[1]] > 1:
                heapq.heappush(redundant, (item[0], item[1]))

        # Max-heap to track the most profitable items not yet selected that add a new category
        addable = []
        for item in remaining:
            if item[1] not in category_count:
                heapq.heappush(addable, (-item[0], item[1]))

        # Try to increase elegance by swapping redundant items with addable items
        while redundant and addable:
            profit_remove, cat_remove = heapq.heappop(redundant)
            profit_add, cat_add = heapq.heappop(addable)
            profit_add = -profit_add

            total_profit = total_profit - profit_remove + profit_add
            distinct_categories += 1
            max_elegance = max(max_elegance, total_profit + distinct_categories**2)

        return max_elegance","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Sort items by profit in descending order
        items.sort(key=lambda x: x[0], reverse=True)
        
        # Initialize variables
        total_profit = 0
        selected_categories = set()
        
        # Iterate through items
        for profit, category in items:
            if len(selected_categories) < k:
                total_profit += profit
                selected_categories.add(category)
            else:
                break
        
        # Calculate elegance
        elegance = total_profit + len(selected_categories) ** 2
        return elegance           solution = Solution()
items = [
    [10, 1],  # Profit = 10, Category = 1
    [20, 2],  # Profit = 20, Category = 2
    [15, 1],  # Profit = 15, Category = 1
    [30, 3],  # Profit = 30, Category = 3
    [25, 2]   # Profit = 25, Category = 2
]
k = 2

print(solution.findMaximumElegance(items, k))  # Output should be 55",hard
16,"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
""""""You are given an array nums of n positive integers and an integer k.

Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:

Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.
Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.
Multiply your score by x.
Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.

The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.

Return the maximum possible score after applying at most k operations.

Since the answer may be large, return it modulo 10^9 + 7.

Example:

Input: nums = [8,3,9,3,8], k = 2
Output: 81
Explanation: To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.


Constraints:

1 <= nums.length == n <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= min(n * (n + 1) / 2, 10^9) """"""","class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res","from heapq import heappush, heappop
from typing import List

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7

        # Step 1: Calculate prime scores for each number up to 10^5
        MAX_VAL = 10**5
        prime_scores = [0] * (MAX_VAL + 1)
        
        # Modified Sieve of Eratosthenes to count distinct prime factors
        for i in range(2, MAX_VAL + 1):
            if prime_scores[i] == 0:  # i is a prime number
                for multiple in range(i, MAX_VAL + 1, i):
                    prime_scores[multiple] += 1

        # Step 2: Collect elements and their prime scores
        max_heap = []
        n = len(nums)
        
        for i in range(n):
            for j in range(i, n):
                subarray_max_score = max((prime_scores[nums[t]], nums[t], t) for t in range(i, j + 1))
                heappush(max_heap, (-subarray_max_score[0], subarray_max_score[1], subarray_max_score[2]))

        # Step 3: Execute the operations up to k times
        score = 1
        
        for _ in range(k):
            if max_heap:
                _, value, _ = heappop(max_heap)
                score = (score * value) % MOD
        
        return score","class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        mod = 10**9 + 7

        # Calculate leftmost indices
        stack_left = []
        left = [0] * n
        for i in range(n):
            while stack_left and nums[i] < nums[stack_left[-1]]:
                left[stack_left.pop()] = i
            stack_left.append(i)

        # Calculate rightmost indices
        stack_right = []
        right = [n - 1] * n
        for i in range(n - 1, -1, -1):
            while stack_right and nums[i] <= nums[stack_right[-1]]:
                right[stack_right.pop()] = i
            stack_right.append(i)

        # Calculate prime score for each element
        prime_score = [0] * n
        for i in range(n):
            num = nums[i]
            while num > 1:
                prime_score[i] += 1
                while num % prime_score[i] == 0:
                    num //= prime_score[i]

        # Calculate maximum score
        max_score = 1
        for i in range(n):
            valid_length = right[i] - left[i] + 1
            max_score = (max_score * pow(nums[i], prime_score[i] * valid_length, mod)) % mod

        return max_score",hard
17,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
""""""You are given a 0-indexed 2D integer array items of length n and an integer k.

items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.

Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.

Your task is to find the maximum elegance from all subsequences of size k in items.

Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.

Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.

Example 1:

Input: items = [[3,2],[5,1],[10,1]], k = 2
Output: 17
Explanation: In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. 

Example 2:

Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
Output: 19
Explanation: In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.

Constraints:

1 <= items.length == n <= 10^5
items[i].length == 2
items[i][0] == profit_i
items[i][1] == category_i
1 <= profit_i <= 10^9
1 <= category_i <= n 
1 <= k <= n """"""","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res","from typing import List
from collections import defaultdict

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Sort items by profit in descending order
        items.sort(key=lambda x: -x[0])
        
        total_profit = 0
        used_categories = defaultdict(int)
        available_items = []
        
        # Select top k items based on profit and calculate initial profit and distinct categories
        for i in range(k):
            profit, category = items[i]
            total_profit += profit
            used_categories[category] += 1
            
        # Add the rest of the items to available_items
        for i in range(k, len(items)):
            available_items.append(items[i])
        
        # Sort available items by profit in descending order
        available_items.sort(key=lambda x: -x[0])
        
        # The initial distinct categories and elegance score
        distinct_categories = len(used_categories)
        max_elegance = total_profit + distinct_categories ** 2
        
        # Try to replace items to maximize the distinct categories
        for item in available_items:
            profit, category = item
            if category not in used_categories:
                # Find the least profitable item to replace
                for i in range(k-1, -1, -1):
                    if used_categories[items[i][1]] > 1:
                        # Replace the item
                        removed_profit = items[i][0]
                        total_profit = total_profit - removed_profit + profit
                        used_categories[items[i][1]] -= 1
                        used_categories[category] += 1
                        distinct_categories += 1
                        
                        # Update the maximum elegance
                        max_elegance = max(max_elegance, total_profit + distinct_categories ** 2)
                        break
        
        return max_elegance

# Example usage:
solution = Solution()
print(solution.findMaximumElegance([[3, 2], [5, 1], [10, 1]], 2))  # Output: 17
print(solution.findMaximumElegance([[3, 1], [3, 1], [2, 2], [5, 3]], 3))  # Output: 19","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Sort items by profit in descending order
        items.sort(key=lambda x: x[0], reverse=True)
        
        # Initialize variables
        total_profit = 0
        distinct_categories = set()
        max_elegance = float('-inf')
        
        # Iterate through items
        for i in range(len(items)):
            profit, category = items[i]
            total_profit += profit
            distinct_categories.add(category)
            
            # If we have more than k items, remove the smallest profit item
            if i >= k:
                smallest_profit, smallest_category = items[i - k]
                total_profit -= smallest_profit
                distinct_categories.discard(smallest_category)
            
            # Calculate elegance
            elegance = total_profit + len(distinct_categories) ** 2
            max_elegance = max(max_elegance, elegance)
        
        return max_elegance

# Example usage
solution = Solution()
items1 = [[3, 2], [5, 1], [10, 1]]
k1 = 2
print(solution.findMaximumElegance(items1, k1))  # Output: 17

items2 = [[3, 1], [3, 1], [2, 2], [5, 3]]
k2 = 3
print(solution.findMaximumElegance(items2, k2))  # Output: 19",medium
18,"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
""""""You are given an array nums of n positive integers and an integer k.

Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:

Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.
Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.
Multiply your score by x.
Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.

The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.

Return the maximum possible score after applying at most k operations.

Since the answer may be large, return it modulo 10^9 + 7.

Example 1:

Input: nums = [8,3,9,3,8], k = 2
Output: 81
Explanation: To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.

Example 2:

Input: nums = [19,12,14,6,10,18], k = 3
Output: 4788
Explanation: To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
 
Constraints:

1 <= nums.length == n <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= min(n * (n + 1) / 2, 10^9).""""""","class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res","from typing import List
import heapq

MOD = 10**9 + 7

def prime_factors_count(n):
    # This function returns the number of distinct prime factors of n
    factors = set()
    if n % 2 == 0:
        factors.add(2)
        while n % 2 == 0:
            n //= 2
    for i in range(3, int(n**0.5) + 1, 2):
        if n % i == 0:
            factors.add(i)
            while n % i == 0:
                n //= i
    if n > 2:
        factors.add(n)
    return len(factors)

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        
        # Precompute prime scores for each number in nums
        max_num = max(nums)
        prime_scores = [0] * (max_num + 1)
        for i in range(2, max_num + 1):
            if prime_scores[i] == 0:
                for j in range(i, max_num + 1, i):
                    prime_scores[j] += 1
        
        # Array to store the prime score of each element in nums
        nums_prime_scores = [prime_scores[num] for num in nums]
        
        # Use a max-heap to keep track of the highest prime scores
        heap = []
        for i in range(n):
            heapq.heappush(heap, (-nums_prime_scores[i], -i, nums[i]))
        
        score = 1
        
        # We need to select elements k times
        for _ in range(k):
            if heap:
                neg_prime_score, neg_index, value = heapq.heappop(heap)
                score = (score * value) % MOD
        
        return score","class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        n = len(nums)
        
        # Calculate the prime score for each number
        def prime_score(num):
            score = 0
            for i in range(2, int(num**0.5) + 1):
                while num % i == 0:
                    score += 1
                    num //= i
            if num > 1:
                score += 1
            return score
        
        # Initialize dp array
        dp = [[0] * (k + 1) for _ in range(n + 1)]
        dp[0][0] = 1
        
        for i in range(1, n + 1):
            for j in range(k + 1):
                # Case 1: Don't choose the current element
                dp[i][j] = dp[i - 1][j]
                
                # Case 2: Choose the current element
                for l in range(i, 0, -1):
                    dp[i][j] = max(dp[i][j], dp[l - 1][j - 1] * nums[l - 1])
        
        # Find the maximum score after applying k operations
        max_score = 0
        for i in range(n):
            max_score = max(max_score, dp[i][k])
        
        return max_score % MOD

# Example usage
solution = Solution()
nums1 = [8, 3, 9, 3, 8]
k1 = 2
print(solution.maximumScore(nums1, k1))  # Output: 81

nums2 = [19, 12, 14, 6, 10, 18]
k2 = 3
print(solution.maximumScore(nums2, k2))  # Output: 4788",hard
19,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
""""""You are given a 0-indexed 2D integer array items of length n and an integer k.

items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.

Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.

Your task is to find the maximum elegance from all subsequences of size k in items.

Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.

Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.

Example 1:

Input: items = [[3,2],[5,1],[10,1]], k = 2
Output: 17
Explanation: In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. 

Example 2:

Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
Output: 19
Explanation: In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.

Example 3:

Input: items = [[1,1],[2,1],[3,1]], k = 3
Output: 7
Explanation: In this example, we have to select a subsequence of size 3. 
We should select all the items. 
The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. 
Hence, the maximum elegance is 6 + 1^2 = 7.  
 
Constraints:

1 <= items.length == n <= 10^5
items[i].length == 2
items[i][0] == profit_i
items[i][1] == category_i
1 <= profit_i <= 10^9
1 <= category_i <= n 
1 <= k <= n""""""","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res","from typing import List
from heapq import heappush, heappop
from collections import defaultdict

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Step 1: Sort items by profit in descending order
        items.sort(key=lambda x: -x[0])
        
        total_profit = 0
        category_count = defaultdict(int)
        min_heap = []  # To track the least profitable items in the top k selection
        
        # Step 2: Initial selection of the top k items
        for i in range(k):
            profit, category = items[i]
            total_profit += profit
            category_count[category] += 1
            heappush(min_heap, (profit, category))
        
        distinct_categories = len(category_count)
        max_elegance = total_profit + distinct_categories ** 2
        
        # Step 3: Optimize by replacing items with same category if possible
        for j in range(k, len(items)):
            profit, category = items[j]
            if category not in category_count:
                while min_heap:
                    min_profit, min_category = heappop(min_heap)
                    if category_count[min_category] > 1:
                        category_count[min_category] -= 1
                        total_profit += profit - min_profit
                        category_count[category] += 1
                        heappush(min_heap, (profit, category))
                        distinct_categories += 1
                        max_elegance = max(max_elegance, total_profit + distinct_categories ** 2)
                        break
                    heappush(min_heap, (min_profit, min_category))
        
        return max_elegance

# Example usage
solution = Solution()
print(solution.findMaximumElegance([[3,2],[5,1],[10,1]], 2))  # Output: 17
print(solution.findMaximumElegance([[3,1],[3,1],[2,2],[5,3]], 3))  # Output: 19
print(solution.findMaximumElegance([[1,1],[2,1],[3,1]], 3))  # Output: 7","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        n = len(items)
        max_elegance = float('-inf')

        # Generate all subsequences of size k
        for mask in range(1 << n):
            if bin(mask).count('1') == k:
                total_profit = 0
                categories = set()

                for i in range(n):
                    if mask & (1 << i):
                        total_profit += items[i][0]
                        categories.add(items[i][1])

                distinct_categories = len(categories)
                elegance = total_profit + distinct_categories ** 2
                max_elegance = max(max_elegance, elegance)

        return max_elegance",hard
20,"prompt = """"""
You are given an array nums of n positive integers and an integer k.

Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:

Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.
Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.
Multiply your score by x.
Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.

The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.

Return the maximum possible score after applying at most k operations.

Since the answer may be large, return it modulo 10^9 + 7.

Example 1:

Input: nums = [8,3,9,3,8], k = 2
Output: 81
Explanation: To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.

Example 2:

Input: nums = [19,12,14,6,10,18], k = 3
Output: 4788
Explanation: To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
 
Constraints:

1 <= nums.length == n <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= min(n * (n + 1) / 2, 10^9)

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
""""""","class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res","from heapq import heappush, heappop
from math import sqrt

MOD = 10**9 + 7

class Solution:
    def maximumScore(self, nums, k):
        n = len(nums)
        
        # Function to compute the prime factors count for every number up to max(nums)
        def sieve(max_num):
            prime_factors = [0] * (max_num + 1)
            for i in range(2, max_num + 1):
                if prime_factors[i] == 0:  # i is a prime number
                    for j in range(i, max_num + 1, i):
                        prime_factors[j] += 1
            return prime_factors
        
        max_num = max(nums)
        prime_scores = sieve(max_num)
        
        # List to store (prime_score, value, index) for all elements
        elements = [(prime_scores[val], val, i) for i, val in enumerate(nums)]
        
        # Sort by prime_score descending, then by value descending, then by index ascending
        elements.sort(key=lambda x: (-x[0], -x[1], x[2]))
        
        score = 1
        subarrays = set()
        
        for prime_score, val, idx in elements:
            # We need to pick subarrays such that we maximize the score
            if k <= 0:
                break
            
            # Include subarray containing only this element
            subarrays.add((idx, idx))
            score = (score * val) % MOD
            k -= 1
            
            # Try to extend subarray to left and right if it results in unique subarrays
            left = idx - 1
            while left >= 0 and (left, idx) not in subarrays and k > 0:
                subarrays.add((left, idx))
                score = (score * val) % MOD
                k -= 1
                left -= 1
            
            right = idx + 1
            while right < n and (idx, right) not in subarrays and k > 0:
                subarrays.add((idx, right))
                score = (score * val) % MOD
                k -= 1
                right += 1
        
        return score

# Example usage:
sol = Solution()
print(sol.maximumScore([8, 3, 9, 3, 8], 2))  # Output: 81
print(sol.maximumScore([19, 12, 14, 6, 10, 18], 3))  # Output: 4788","def maxScore(nums, k):
    MOD = 10**9 + 7
    n = len(nums)
    
    # Calculate the prime factors of each element
    prime_factors = [0] * n
    for i in range(n):
        num = nums[i]
        while num % 2 == 0:
            prime_factors[i] += 1
            num //= 2
        for j in range(3, int(num**0.5) + 1, 2):
            while num % j == 0:
                prime_factors[i] += 1
                num //= j
        if num > 1:
            prime_factors[i] += 1
    
    # Initialize dp array
    dp = [[0] * (k + 1) for _ in range(n)]
    for i in range(n):
        dp[i][0] = pow(2, prime_factors[i], MOD)
    
    # Update dp array
    for i in range(1, n):
        for j in range(1, k + 1):
            dp[i][j] = dp[i-1][j]
            for l in range(i):
                dp[i][j] = max(dp[i][j], dp[l][j-1] * pow(2, prime_factors[i], MOD))
    
    # Calculate the maximum score
    max_score = 0
    for j in range(k + 1):
        max_score = max(max_score, dp[n-1][j])
    
    return max_score

# Example usage
nums1 = [8, 3, 9, 3, 8]
k1 = 2
print(maxScore(nums1, k1))  # Output: 81

nums2 = [19, 12, 14, 6, 10, 18]
k2 = 3
print(maxScore(nums2, k2))  # Output: 4788",hard
21,"prompt = """"""
You are given a 0-indexed 2D integer array items of length n and an integer k.

items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.

Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.

Your task is to find the maximum elegance from all subsequences of size k in items.

Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.

Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.

Example 1:

Input: items = [[3,2],[5,1],[10,1]], k = 2
Output: 17
Explanation: In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. 

Example 2:

Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
Output: 19
Explanation: In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.

Example 3:

Input: items = [[1,1],[2,1],[3,1]], k = 3
Output: 7
Explanation: In this example, we have to select a subsequence of size 3. 
We should select all the items. 
The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. 
Hence, the maximum elegance is 6 + 1^2 = 7.  
 
Constraints:

1 <= items.length == n <= 10^5
items[i].length == 2
items[i][0] == profit_i
items[i][1] == category_i
1 <= profit_i <= 10^9
1 <= category_i <= n 
1 <= k <= n

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
""""""","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res","import heapq
from collections import defaultdict

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Step 1: Sort items by profit in descending order
        items.sort(key=lambda x: -x[0])
        
        # Variables to keep track of the current selection
        total_profit = 0
        category_count = defaultdict(int)
        min_heap = []
        
        # Step 2: Initialize by selecting the top k items
        for i in range(k):
            profit, category = items[i]
            total_profit += profit
            category_count[category] += 1
            heapq.heappush(min_heap, (profit, category))
        
        distinct_categories = len(category_count)
        max_elegance = total_profit + distinct_categories ** 2
        
        # Step 3: Try to replace items to increase the number of distinct categories
        for i in range(k, len(items)):
            profit, category = items[i]
            
            # Skip if this category is already included in the current selection
            if category in category_count:
                continue
            
            # Otherwise, we try to replace the smallest profit item from a duplicate category
            while min_heap and category_count[min_heap[0][1]] == 1:
                heapq.heappop(min_heap)
            
            if not min_heap:
                break
            
            min_profit, min_category = heapq.heappop(min_heap)
            
            # Update the total profit and category count
            total_profit = total_profit - min_profit + profit
            category_count[min_category] -= 1
            if category_count[min_category] == 0:
                del category_count[min_category]
            
            category_count[category] += 1
            heapq.heappush(min_heap, (profit, category))
            
            distinct_categories = len(category_count)
            max_elegance = max(max_elegance, total_profit + distinct_categories ** 2)
        
        return max_elegance","def max_elegance(items, k):
    # Sort items by profit in descending order
    items.sort(key=lambda x: x[0], reverse=True)
    
    # Initialize variables
    total_profit = 0
    distinct_categories = set()
    max_elegance = 0
    
    for profit, category in items:
        total_profit += profit
        distinct_categories.add(category)
        
        # Remove smallest category if size exceeds k
        while len(distinct_categories) > k:
            smallest_category = min(distinct_categories)
            distinct_categories.remove(smallest_category)
        
        # Calculate elegance
        elegance = total_profit + len(distinct_categories) ** 2
        max_elegance = max(max_elegance, elegance)
    
    return max_elegance

# Example usage
items1 = [[3, 2], [5, 1], [10, 1]]
k1 = 2
print(max_elegance(items1, k1))  # Output: 17

items2 = [[3, 1], [3, 1], [2, 2], [5, 3]]
k2 = 3
print(max_elegance(items2, k2))  # Output: 19

items3 = [[1, 1], [2, 1], [3, 1]]
k3 = 3
print(max_elegance(items3, k3))  # Output: 7",hard
22,"class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
""""""You are given an array nums of n positive integers and an integer k.

Initially, you start with a score of 1. You have to maximize your score by applying the following operation at most k times:

Choose any non-empty subarray nums[l, ..., r] that you haven't chosen previously.
Choose an element x of nums[l, ..., r] with the highest prime score. If multiple such elements exist, choose the one with the smallest index.
Multiply your score by x.
Here, nums[l, ..., r] denotes the subarray of nums starting at index l and ending at the index r, both ends being inclusive.

The prime score of an integer x is equal to the number of distinct prime factors of x. For example, the prime score of 300 is 3 since 300 = 2 * 2 * 3 * 5 * 5.

Return the maximum possible score after applying at most k operations.

Since the answer may be large, return it modulo 10^9 + 7.

Example 1:

Input: nums = [8,3,9,3,8], k = 2
Output: 81
Explanation: To get a score of 81, we can apply the following operations:
- Choose subarray nums[2, ..., 2]. nums[2] is the only element in this subarray. Hence, we multiply the score by nums[2]. The score becomes 1 * 9 = 9.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 1, but nums[2] has the smaller index. Hence, we multiply the score by nums[2]. The score becomes 9 * 9 = 81.
It can be proven that 81 is the highest score one can obtain.

Example 2:

Input: nums = [19,12,14,6,10,18], k = 3
Output: 4788
Explanation: To get a score of 4788, we can apply the following operations: 
- Choose subarray nums[0, ..., 0]. nums[0] is the only element in this subarray. Hence, we multiply the score by nums[0]. The score becomes 1 * 19 = 19.
- Choose subarray nums[5, ..., 5]. nums[5] is the only element in this subarray. Hence, we multiply the score by nums[5]. The score becomes 19 * 18 = 342.
- Choose subarray nums[2, ..., 3]. Both nums[2] and nums[3] have a prime score of 2, but nums[2] has the smaller index. Hence, we multipy the score by nums[2]. The score becomes 342 * 14 = 4788.
It can be proven that 4788 is the highest score one can obtain.
 
Constraints:

1 <= nums.length == n <= 10^5
1 <= nums[i] <= 10^5
1 <= k <= min(n * (n + 1) / 2, 10^9) """"""","class Solution: 
    MOD = 1000000007

    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)

        upper = max(nums) + 1

        prime = [True]*upper
        prime[0] = prime[1] = False
        primeScore = [0]*upper
        for i in range(2, upper):
            if prime[i]:
                for j in range(i, upper, i):
                    primeScore[j] += 1
                    prime[j] = False

        nextGreaterElement = [n]*n
        s = []
        for i in range(n - 1, -1, -1):
            while s and primeScore[nums[i]] >= primeScore[nums[s[-1]]]:
                s.pop()
            nextGreaterElement[i] = s[-1] if s else n
            s.append(i)

        prevGreaterOrEqualElement = [-1]*n
        s = []
        for i in range(n):
            while s and primeScore[nums[i]] > primeScore[nums[s[-1]]]:
                s.pop()
            prevGreaterOrEqualElement[i] = s[-1] if s else -1
            s.append(i)

        res = 1
        tuples = [[nums[i], i] for i in range(n)]
        tuples.sort(reverse=True)
        for num, idx in tuples:
            operations = min((idx - prevGreaterOrEqualElement[idx]) * (nextGreaterElement[idx] - idx), k)
            res = (res * self.pow(num, operations)) % self.MOD
            k -= operations
            if k == 0:
                return res

        return res

    def pow(self, x: int, n: int) -> int:
        res = 1
        while n > 0:
            if n % 2 == 1:
                res = (res * x) % self.MOD
            x = (x * x) % self.MOD
            n //= 2
        return res","from typing import List
import heapq
from collections import defaultdict

class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        MOD = 10**9 + 7
        
        # Helper function to calculate the number of distinct prime factors
        def prime_factors_count(n):
            if n < 2:
                return 0
            count = 0
            d = 2
            while d * d <= n:
                if n % d == 0:
                    count += 1
                    while n % d == 0:
                        n //= d
                d += 1
            if n > 1:
                count += 1
            return count
        
        # Precompute the prime scores for all numbers up to 10^5
        max_val = 10**5
        prime_scores = [0] * (max_val + 1)
        for i in range(2, max_val + 1):
            if prime_scores[i] == 0:
                for j in range(i, max_val + 1, i):
                    prime_scores[j] += 1
        
        n = len(nums)
        
        # Create a list of elements with their prime scores and indexes
        elements = [(prime_scores[nums[i]], i, nums[i]) for i in range(n)]
        
        # Sort elements by prime score in descending order, then by index in ascending order
        elements.sort(reverse=True, key=lambda x: (x[0], -x[1]))
        
        # Use a max heap to track the maximum score
        heap = []
        for ps, idx, val in elements:
            heapq.heappush(heap, (-ps, idx, val))
        
        # Calculate the maximum score by picking the highest prime score elements
        score = 1
        used_subarrays = set()
        
        while k > 0 and heap:
            _, idx, val = heapq.heappop(heap)
            subarray = (idx, idx)
            if subarray not in used_subarrays:
                score = (score * val) % MOD
                used_subarrays.add(subarray)
                k -= 1
        
        return score

# Example usage:
sol = Solution()
print(sol.maximumScore([8, 3, 9, 3, 8], 2))  # Output: 81
print(sol.maximumScore([19, 12, 14, 6, 10, 18], 3))  # Output: 4788","class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        dp = [0] * n
        dp[0] = nums[0]

        for i in range(1, n):
            dp[i] = nums[i]
            for j in range(i, max(0, i-k), -1):
                dp[i] = max(dp[i], dp[j] * nums[i])

        return max(dp) % (10**9 + 7)",hard
23,"class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
""""""You are given a 0-indexed 2D integer array items of length n and an integer k.

items[i] = [profit_i, category_i], where profit_i and category_i denote the profit and category of the i^th item respectively.

Let's define the elegance of a subsequence of items as total_profit + distinct_categories^2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.

Your task is to find the maximum elegance from all subsequences of size k in items.

Return an integer denoting the maximum elegance of a subsequence of items with size exactly k.

Note: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.

Example 1:

Input: items = [[3,2],[5,1],[10,1]], k = 2
Output: 17
Explanation: In this example, we have to select a subsequence of size 2.
We can select items[0] = [3,2] and items[2] = [10,1].
The total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].
Hence, the elegance is 13 + 2^2 = 17, and we can show that it is the maximum achievable elegance. 

Example 2:

Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3
Output: 19
Explanation: In this example, we have to select a subsequence of size 3. 
We can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. 
The total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. 
Hence, the elegance is 10 + 3^2 = 19, and we can show that it is the maximum achievable elegance.

Example 3:

Input: items = [[1,1],[2,1],[3,1]], k = 3
Output: 7
Explanation: In this example, we have to select a subsequence of size 3. 
We should select all the items. 
The total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. 
Hence, the maximum elegance is 6 + 1^2 = 7.  
 
Constraints:

1 <= items.length == n <= 10^5
items[i].length == 2
items[i][0] == profit_i
items[i][1] == category_i
1 <= profit_i <= 10^9
1 <= category_i <= n 
1 <= k <= n """"""","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        items = sorted(items, key=lambda v: -v[0])
        res = cur = 0
        A = []
        seen = set()
        for i, (p, c) in enumerate(items):
            if i < k:
                if c in seen:
                    A.append(p)
                cur += p
            elif c not in seen:
                if not A: break
                cur += p - A.pop()
            seen.add(c)
            res = max(res, cur + len(seen) * len(seen))
        return res","from heapq import heappop, heappush, heapify
from collections import defaultdict

class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Step 1: Sort items by profit in descending order
        items.sort(key=lambda x: -x[0])
        
        total_profit = 0
        category_count = defaultdict(int)
        min_heap = []
        
        # Step 2: Initial selection of the top k items
        for i in range(k):
            profit, category = items[i]
            total_profit += profit
            category_count[category] += 1
            heappush(min_heap, (profit, category))
        
        # Calculate initial elegance
        distinct_categories = len(category_count)
        max_elegance = total_profit + distinct_categories ** 2
        
        # Step 3: Evaluate remaining items for potential replacement
        for i in range(k, len(items)):
            profit, category = items[i]
            if category not in category_count:
                while min_heap:
                    min_profit, min_category = heappop(min_heap)
                    if category_count[min_category] > 1:
                        category_count[min_category] -= 1
                        total_profit -= min_profit
                        total_profit += profit
                        category_count[category] += 1
                        distinct_categories += 1
                        max_elegance = max(max_elegance, total_profit + distinct_categories ** 2)
                        heappush(min_heap, (profit, category))
                        break
                    else:
                        heappush(min_heap, (min_profit, min_category))
        
        return max_elegance","class Solution:
    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:
        # Initialize a dictionary to store maximum profit for each category
        max_profit_by_category = {}
        
        # Update maximum profit for each category
        for profit, category in items:
            max_profit_by_category[category] = max(max_profit_by_category.get(category, 0), profit)
        
        # Sort items by profit in descending order
        sorted_items = sorted(items, key=lambda x: x[0], reverse=True)
        
        # Initialize variables
        total_profit = 0
        distinct_categories = 0
        
        # Select top k items
        for i in range(k):
            total_profit += sorted_items[i][0]
            if sorted_items[i][1] not in max_profit_by_category:
                distinct_categories += 1
        
        # Calculate elegance
        elegance = total_profit + distinct_categories**2
        return elegance    solution = Solution()
items = [
    [10, 1],  # Profit = 10, Category = 1
    [20, 2],  # Profit = 20, Category = 2
    [15, 1],  # Profit = 15, Category = 1
    [30, 3],  # Profit = 30, Category = 3
    [25, 2]   # Profit = 25, Category = 2
]
k = 3

print(solution.findMaximumElegance(items, k))  # Expected output: 120",hard
28,"class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
""""""You are given a 0-indexed integer array nums and an integer x.

Find the minimum absolute difference between two elements in the array that are at least x indices apart.

In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.

Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.

Example 1:

Input: nums = [4,3,2,4], x = 2
Output: 0
Explanation: We can select nums[0] = 4 and nums[3] = 4. 
They are at least 2 indices apart, and their absolute difference is the minimum, 0. 
It can be shown that 0 is the optimal answer.

Example 2:

Input: nums = [5,3,2,10,15], x = 1
Output: 1
Explanation: We can select nums[1] = 3 and nums[2] = 2.
They are at least 1 index apart, and their absolute difference is the minimum, 1.
It can be shown that 1 is the optimal answer.

Example 3:

Input: nums = [1,2,3,4], x = 3
Output: 3
Explanation: We can select nums[0] = 1 and nums[3] = 4.
They are at least 3 indices apart, and their absolute difference is the minimum, 3.
It can be shown that 3 is the optimal answer.
 
Constraints:

1 <= nums.length <= 10^5
1 <= nums[i] <= 10^9
0 <= x < nums.length """"""","class Solution:
  def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
    if x == 0:
      return 0

    arr, best_dist = SortedList([]), float('inf')
    for i in range(x, len(nums)):
      arr.add(nums[i - x])
      v = nums[i]

      pos = arr.bisect_left(v)
      if pos < len(arr):
        best_dist = min(best_dist, abs(arr[pos] - v))
      if pos > 0:
        best_dist = min(best_dist, abs(arr[pos - 1] - v))
    
    return best_dist","from sortedcontainers import SortedList
from typing import List


class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        if x == 0:
            return 0  # If x is 0, then any pair of elements is valid, but x=0 is not allowed by constraints.

        min_diff = float('inf')
        sorted_list = SortedList()

        for i in range(x, len(nums)):
            sorted_list.add(nums[i - x])

            # Find the closest element in the sorted list to nums[i]
            pos = sorted_list.bisect_left(nums[i])

            # Check with the element just before the current position (if it exists)
            if pos > 0:
                min_diff = min(min_diff, abs(nums[i] - sorted_list[pos - 1]))

            # Check with the element at the current position (if it exists)
            if pos < len(sorted_list):
                min_diff = min(min_diff, abs(nums[i] - sorted_list[pos]))

        return min_diff
solution = Solution()
nums = [4, 2, 1, 7]
x = 1
print(solution.minAbsoluteDifference(nums, x))  # Expected output: 1
solution = Solution()
nums = [8, 1, 9, 4, 3, 2]
x = 2
print(solution.minAbsoluteDifference(nums, x))  # Expected output: 1
solution = Solution()
nums = [5, 15, 30, 25]
x = 1
print(solution.minAbsoluteDifference(nums, x))  # Expected output: 5","class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        nums.sort()  # Sort the array in ascending order
        n = len(nums)
        min_diff = float('inf')  # Initialize min_diff with positive infinity

        # Initialize pointers for the sliding window
        left, right = 0, 0

        while right < n:
            # Check if the current window size is at least x
            if right - left >= x:
                # Calculate the absolute difference between max and min in the window
                diff = nums[right] - nums[left]
                min_diff = min(min_diff, diff)

                # Move the left pointer to slide the window
                left += 1

            # Move the right pointer to expand the window
            right += 1

        return min_diff                      solution = Solution()
nums = [1, 5, 3, 19, 18, 26]
x = 3

print(solution.minAbsoluteDifference(nums, x))  # Expected output: 4",medium
29,"class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
""""""You are given the head of a non-empty linked list representing a non-negative integer without leading zeroes.

Return the head of the linked list after doubling it.

Example 1:

Input: head = [1,8,9]
Output: [3,7,8]
Explanation: The figure above corresponds to the given linked list which represents the number 189. Hence, the returned linked list represents the number 189 * 2 = 378.

Example 2:

Input: head = [9,9,9]
Output: [1,9,9,8]
Explanation: The figure above corresponds to the given linked list which represents the number 999. Hence, the returned linked list reprersents the number 999 * 2 = 1998. 

Constraints:

The number of nodes in the list is in the range [1, 10^4]
0 <= Node.val <= 9
The input is generated such that the list represents a number that does not have leading zeros, except the number 0 itself. """"""","class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if head.val > 4:
            head = ListNode(0, head)
        node = head
        while node:
            node.val = (node.val * 2) % 10
            if node.next and node.next.val > 4:
                node.val += 1
            node = node.next
        return head","from typing import Optional

# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # Step 1: Convert linked list to number
        num = 0
        current = head
        while current:
            num = num * 10 + current.val
            current = current.next

        # Step 2: Double the number
        doubled_num = num * 2

        # Step 3: Convert doubled number back to linked list
        dummy_head = ListNode(0)
        current = dummy_head
        for digit in str(doubled_num):
            current.next = ListNode(int(digit))
            current = current.next

        return dummy_head.next

# Helper function to print the linked list
def print_linked_list(head: Optional[ListNode]):
    while head:
        print(head.val, end="" -> "" if head.next else ""\n"")
        head = head.next

# Example usage
# Example 1
head1 = ListNode(1, ListNode(2, ListNode(3)))  # represents the number 123
solution = Solution()
doubled_list1 = solution.doubleIt(head1)  # Expected output: 246
print_linked_list(doubled_list1)  # Output: 2 -> 4 -> 6

# Example 2
head2 = ListNode(9, ListNode(9, ListNode(9)))  # represents the number 999
doubled_list2 = solution.doubleIt(head2)  # Expected output: 1998
print_linked_list(doubled_list2)  # Output: 1 -> 9 -> 9 -> 8

# Example 3
head3 = ListNode(4)  # represents the number 4
doubled_list3 = solution.doubleIt(head3)  # Expected output: 8
print_linked_list(doubled_list3)  # Output: 8

# Example 4
head4 = ListNode(5, ListNode(0, ListNode(1)))  # represents the number 501
doubled_list4 = solution.doubleIt(head4)  # Expected output: 1002
print_linked_list(doubled_list4)  # Output: 1 -> 0 -> 0 -> 2","from typing import List, Optional

class Solution:
    def doubleIt(self, head: Optional[List[int]]) -> Optional[List[int]]:
        if not head:
            return None

        dummy = [0]  # Dummy node for handling carryover
        dummy.extend(head)
        n = len(head)
        carry = 0

        for i in range(n - 1, -1, -1):
            dummy[i + 1] = dummy[i + 1] * 2 + carry
            carry = dummy[i + 1] // 10
            dummy[i + 1] %= 10

        if carry:
            dummy[0] = carry
        else:
            dummy.pop(0)  # Remove dummy node if no carry

        return dummy

# Helper function to create a list representation of a linked list
def create_linked_list(arr):
    return arr

# Helper function to print a list representation of a linked list
def print_linked_list(arr):
    print("" -> "".join(map(str, arr)))

# Examples
if __name__ == ""__main__"":
    solution = Solution()

    # Example 1
    nums1 = create_linked_list([1, 2, 3])
    result1 = solution.doubleIt(nums1)
    print(""Example 1:"")
    print_linked_list(result1)  # Expected output: 2 -> 4 -> 6

    # Example 2
    nums2 = create_linked_list([9, 9, 9])
    result2 = solution.doubleIt(nums2)
    print(""Example 2:"")
    print_linked_list(result2)  # Expected output: 8 -> 0 -> 0 -> 1",medium
30,"Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return the median of the two sorted arrays.


Example 1:
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.


Example 2:
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.


Example 3:
Input: nums1 = [0,0], nums2 = [0,0]
Output: 0.00000

Example 4:
Input: nums1 = [], nums2 = [1]
Output: 1.00000

Example 5:
Input: nums1 = [2], nums2 = []
Output: 2.00000

Constraints:
`nums1.length == m`
`nums2.length == n`
`0 <= m <= 1000`
`0 <= n <= 1000`
`1 <= m + n <= 2000`
`-106 <= nums1[i], nums2[i] <= 106`
Follow up: The overall run time complexity should be `O(log (m+n))`.",,"def findMedianSortedArrays(nums1, nums2):
    # Ensure nums1 is the smaller array for optimized binary search
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1

    m, n = len(nums1), len(nums2)
    imin, imax, half_len = 0, m, (m + n + 1) // 2

    while imin <= imax:
        i = (imin + imax) // 2
        j = half_len - i

        if i < m and nums2[j-1] > nums1[i]:
            # i is too small, must increase it
            imin = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            # i is too big, must decrease it
            imax = i - 1
        else:
            # i is perfect
            if i == 0: max_of_left = nums2[j-1]
            elif j == 0: max_of_left = nums1[i-1]
            else: max_of_left = max(nums1[i-1], nums2[j-1])

            if (m + n) % 2 == 1:
                return max_of_left

            if i == m: min_of_right = nums2[j]
            elif j == n: min_of_right = nums1[i]
            else: min_of_right = min(nums1[i], nums2[j])

            return (max_of_left + min_of_right) / 2.0

# Examples
print(findMedianSortedArrays([1,3], [2]))         # Output: 2.0
print(findMedianSortedArrays([1,2], [3,4]))       # Output: 2.5
print(findMedianSortedArrays([0,0], [0,0]))       # Output: 0.0
print(findMedianSortedArrays([], [1]))            # Output: 1.0
print(findMedianSortedArrays([2], []))            # Output: 2.0","def findMedianSortedArrays(nums1, nums2):
    # Ensure nums1 is the smaller array
    if len(nums1) > len(nums2):
        nums1, nums2 = nums2, nums1
    
    m, n = len(nums1), len(nums2)
    total = m + n
    half = total // 2
    
    # Binary search on the smaller array
    left, right = 0, m
    while left <= right:
        i = (left + right) // 2
        j = half - i
        
        # Check if i and j are positioned correctly
        if i < m and nums2[j-1] > nums1[i]:
            left = i + 1
        elif i > 0 and nums1[i-1] > nums2[j]:
            right = i - 1
        else:
            # Found correct partition
            if i == 0: min_left = nums2[j-1]
            elif j == 0: min_left = nums1[i-1]
            else: min_left = max(nums1[i-1], nums2[j-1])
            
            if total % 2 == 1:
                return min_left
            
            if i == m: min_right = nums2[j]
            elif j == n: min_right = nums1[i]
            else: min_right = min(nums1[i], nums2[j])
            
            return (min_left + min_right) / 2.0

# Example usage:
nums1 = [1,3]
nums2 = [2]
print(findMedianSortedArrays(nums1, nums2)) # Output: 2.00000",medium
31,"Given a string `s`, return the longest palindromic substring in `s`.


Example 1:
Input: s = ""babad""
Output: ""bab""
Note: ""aba"" is also a valid answer.


Example 2:
Input: s = ""cbbd""
Output: ""bb""

Example 3:
Input: s = ""a""
Output: ""a""

Example 4:
Input: s = ""ac""
Output: ""a""

Constraints:
`1 <= s.length <= 1000`
`s` consist of only digits and English letters (lower-case and/or upper-case),",,"def longestPalindrome(s):
    if not s or len(s) == 0:
        return """"
    
    start, end = 0, 0
    
    def expandAroundCenter(s, left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return left + 1, right - 1
    
    for i in range(len(s)):
        # For odd length palindromes
        l1, r1 = expandAroundCenter(s, i, i)
        # For even length palindromes
        l2, r2 = expandAroundCenter(s, i, i + 1)
        
        if r1 - l1 > end - start:
            start, end = l1, r1
        if r2 - l2 > end - start:
            start, end = l2, r2
    
    return s[start:end + 1]

# Examples
print(longestPalindrome(""babad""))  # Output: ""bab"" or ""aba""
print(longestPalindrome(""cbbd""))   # Output: ""bb""
print(longestPalindrome(""a""))      # Output: ""a""
print(longestPalindrome(""ac""))     # Output: ""a"" or ""c""","def longestPalindrome(s: str) -> str:
    n = len(s)
    if n < 2:
        return s

    start, max_length = 0, 1
    dp = [[False] * n for _ in range(n)]

    # All substrings of length 1 are palindromes
    for i in range(n):
        dp[i][i] = True

    # Check for substrings of length 2
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            max_length = 2

    # Check for substrings of length greater than 2
    for length in range(3, n + 1):
        for i in range(n - length + 1):
            j = i + length - 1
            if s[i] == s[j] and dp[i + 1][j - 1]:
                dp[i][j] = True
                start = i
                max_length = length

    return s[start:start + max_length]

# Example usage:
print(longestPalindrome(""babad"")) # Output: ""bab"" or ""aba""
print(longestPalindrome(""cbbd"")) # Output: ""bb""
print(longestPalindrome(""a"")) # Output: ""a""
print(longestPalindrome(""ac"")) # Output: ""a""",medium
32,"Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:
Open brackets must be closed by the same type of brackets.

Open brackets must be closed in the correct order.


Example 1:
Input: s = ""()""
Output: true

Example 2:
Input: s = ""()[]{}""
Output: true

Example 3:
Input: s = ""(]""
Output: false

Example 4:
Input: s = ""([)]""
Output: false

Example 5:
Input: s = ""{[]}""
Output: true

Constraints:
`1 <= s.length <= 104`
`s` consists of parentheses only `'()[]{}'`.",,"def isValid(s: str) -> bool:
    # Dictionary to match opening and closing brackets
    matching_bracket = {')': '(', '}': '{', ']': '['}
    
    # Stack to hold opening brackets
    stack = []
    
    # Traverse each character in the string
    for char in s:
        if char in matching_bracket:
            # Check if stack is non-empty and the top of stack is the matching opening bracket
            if stack and stack[-1] == matching_bracket[char]:
                stack.pop()  # Pop the matching opening bracket
            else:
                return False  # Invalid if no match or stack is empty
        else:
            # It's an opening bracket, push onto the stack
            stack.append(char)
    
    # If the stack is empty, all brackets matched correctly
    return not stack

# Examples to test the function
print(isValid(""()""))       # Output: True
print(isValid(""()[]{}""))   # Output: True
print(isValid(""(]""))       # Output: False
print(isValid(""([)]""))     # Output: False
print(isValid(""{[]}""))     # Output: True","def isValid(s: str) -> bool:
    stack = []
    mapping = {"")"": ""("", ""}"": ""{"", ""]"": ""[""}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)

    return not stack

# Example usage:
print(isValid(""()""))       # Output: true
print(isValid(""()[]{}""))   # Output: true
print(isValid(""(]""))       # Output: false
print(isValid(""([)]""))     # Output: false
print(isValid(""{[]}""))     # Output: true",easy
33,"Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

Follow up:
Could you solve the problem in `O(1)` extra memory space?
You may not alter the values in the list's nodes, only nodes itself may be changed.


Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]

Example 3:
Input: head = [1,2,3,4,5], k = 1
Output: [1,2,3,4,5]

Example 4:
Input: head = [1], k = 1
Output: [1]

Constraints:
The number of nodes in the list is in the range `sz`.

`1 <= sz <= 5000`
`0 <= Node.val <= 1000`
`1 <= k <= sz`",,"class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head: ListNode, k: int) -> ListNode:
    def reverseLinkedList(head, k):
        prev, curr = None, head
        while k > 0:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
            k -= 1
        return prev

    count = 0
    node = head
    
    # Count the number of nodes in the linked list
    while node:
        count += 1
        node = node.next

    dummy = ListNode(0)
    dummy.next = head
    prev_end = dummy
    
    while count >= k:
        start = prev_end.next
        end = start
        
        # Move end pointer k nodes ahead
        for _ in range(k - 1):
            end = end.next
        
        next_start = end.next
        
        # Reverse k nodes
        end.next = None
        prev_end.next = reverseLinkedList(start, k)
        
        start.next = next_start
        prev_end = start
        count -= k
    
    return dummy.next

# Example usage:
# Constructing the linked list: [1,2,3,4,5]
node1 = ListNode(1)
node2 = ListNode(2)
node3 = ListNode(3)
node4 = ListNode(4)
node5 = ListNode(5)

node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5

# Applying reverseKGroup function
k = 2
new_head = reverseKGroup(node1, k)

# Output the reversed list
output = []
while new_head:
    output.append(new_head.val)
    new_head = new_head.next
print(output)  # Output: [2, 1, 4, 3, 5]","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseKGroup(head, k):
    if head is None or k == 1:
        return head

    dummy = ListNode(0)
    dummy.next = head
    curr, prev, next = dummy, dummy, dummy
    count = 0

    # Count the number of nodes in the list
    while curr.next:
        curr = curr.next
        count += 1

    # Reverse nodes in groups of k
    while count >= k:
        curr = prev.next
        next = curr.next
        for i in range(1, k):
            curr.next = next.next
            next.next = prev.next
            prev.next = next
            next = curr.next
        prev = curr
        count -= k

    return dummy.next     node1 = ListNode(1)
node2 = ListNode(2)
node3 = ListNode(3)
node4 = ListNode(4)
node5 = ListNode(5)

node1.next = node2
node2.next = node3
node3.next = node4
node4.next = node5

# Applying reverseKGroup function
k = 2
new_head = reverseKGroup(node1, k)

# Output the reversed list
output = []
while new_head:
    output.append(new_head.val)
    new_head = new_head.next
print(output)  # Output: [2, 1, 4, 3, 5]",medium
34,"Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Clarification:
Confused why the returned value is an integer but your answer is an array?
Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.

Internally you can think of this:
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);
// any modification to nums in your function would be known by the caller.

// using the length returned by your function, it prints the first len elements.

for (int i = 0; i < len; i++) {
    print(nums[i]);
}

Example 1:
Input: nums = [1,1,2]
Output: 2, nums = [1,2]
Explanation: Your function should return length = `2`, with the first two elements of `nums` being `1` and `2` respectively. It doesn't matter what you leave beyond the returned length.


Example 2:
Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4]
Explanation: Your function should return length = `5`, with the first five elements of `nums` being modified to `0`, `1`, `2`, `3`, and `4` respectively. It doesn't matter what values are set beyond the returned length.


Constraints:
`0 <= nums.length <= 3 * 104`
`-104 <= nums[i] <= 104`
`nums` is sorted in ascending order.",,"def removeDuplicates(nums):
    if not nums:
        return 0  

    # Initialize the first pointernums = [1, 1, 2]
length = removeDuplicates(nums)
print(length)  # Output: 2
print(nums[:length])  # Output: [1, 2]
    i = 0
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
length = removeDuplicates(nums)
print(length)  # Output: 5
print(nums[:length])  # Output: [0, 1, 2, 3, 4]
    # Iterate through the array with the second pointer
    for j in range(1, len(nums)):
        if nums[j] != nums[i]:
            # Move the first pointer and update the element
            i += 1
            nums[i] = nums[j]

    # The new length is the index of the first pointer + 1
    return i + 1     ","def removeDuplicates(nums):
    if not nums:
        return 0

    # Initialize the counter and the second pointer.
    i = 0

    # Go through each number in the array.
    for j in range(1, len(nums)):
        # If the current number is different from the previous,
        # increment the counter and update the number at the counter position.
        if nums[j] != nums[i]:
            i += 1
            nums[i] = nums[j]

    # The new length is the index of the last unique number + 1
    return i + 1",easy
35,"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.


Example 1:
Input: nums = [1,3,5,6], target = 5
Output: 2

Example 2:
Input: nums = [1,3,5,6], target = 2
Output: 1

Example 3:
Input: nums = [1,3,5,6], target = 7
Output: 4

Example 4:
Input: nums = [1,3,5,6], target = 0
Output: 0

Example 5:
Input: nums = [1], target = 0
Output: 0

Constraints:
`1 <= nums.length <= 104`
`-104 <= nums[i] <= 104`
`nums` contains distinct values sorted in ascending order.

`-104 <= target <= 104`",,"def search_insert(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return left    # Example 1
print(search_insert([1,3,5,6], 5))  # Output: 2

# Example 2
print(search_insert([1,3,5,6], 2))  # Output: 1

# Example 3
print(search_insert([1,3,5,6], 7))  # Output: 4

# Example 4
print(search_insert([1,3,5,6], 0))  # Output: 0

# Example 5
print(search_insert([1], 0))  # Output: 0","def search_insert(nums, target):
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
            
    return left

# Example usage:
print(search_insert([1,3,5,6], 5)) # Output: 2
print(search_insert([1,3,5,6], 2)) # Output: 1
print(search_insert([1,3,5,6], 7)) # Output: 4
print(search_insert([1,3,5,6], 0)) # Output: 0
print(search_insert([1], 0))       # Output: 0",easy
36,"Given an unsorted integer array `nums`, find the smallest missing positive integer.


Example 1:
Input: nums = [1,2,0]
Output: 3

Example 2:
Input: nums = [3,4,-1,1]
Output: 2

Example 3:
Input: nums = [7,8,9,11,12]
Output: 1

Constraints:
`0 <= nums.length <= 300`
`-231 <= nums[i] <= 231 - 1`
Follow up: Could you implement an algorithm that runs in `O(n)` time and uses constant extra space?",,"def firstMissingPositive(nums):
    n = len(nums)
    
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            correct_index = nums[i] - 1
            nums[i], nums[correct_index] = nums[correct_index], nums[i]
    
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    
    return n + 1

# Example 1
nums1 = [1, 2, 0]
output1 = firstMissingPositive(nums1)
print(f""Example 1 - Input: {nums1}, Output: {output1}"")

# Example 2
nums2 = [3, 4, -1, 1]
output2 = firstMissingPositive(nums2)
print(f""Example 2 - Input: {nums2}, Output: {output2}"")

# Example 3
nums3 = [7, 8, 9, 11, 12]
output3 = firstMissingPositive(nums3)
print(f""Example 3 - Input: {nums3}, Output: {output3}"")

# Additional Example 4
nums4 = [2, 3, 7, 6, 8, -1, -10, 15]
output4 = firstMissingPositive(nums4)
print(f""Additional Example 4 - Input: {nums4}, Output: {output4}"")

# Additional Example 5
nums5 = [1, 1, 0, -1, -2]
output5 = firstMissingPositive(nums5)
print(f""Additional Example 5 - Input: {nums5}, Output: {output5}"")","def firstMissingPositive(nums):
    n = len(nums)
    for i in range(n):
        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]
    
    for i in range(n):
        if nums[i] != i + 1:
            return i + 1
    return n + 1       print(firstMissingPositive([1,2,0])) # Output: 3
print(firstMissingPositive([3,4,-1,1])) # Output: 2
print(firstMissingPositive([7,8,9,11,12])) # Output: 1",medium
37,"Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.


Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.


Example 2:
Input: nums = [1]
Output: 1

Example 3:
Input: nums = [5,4,-1,7,8]
Output: 23

Constraints:
`1 <= nums.length <= 3 * 104`
`-105 <= nums[i] <= 105`
Follow up: If you have figured out the `O(n)` solution, try coding another solution using the divide and conquer approach, which is more subtle.",,"def maxSubArrayKadane(nums):
    max_sum = nums[0]
    current_sum = nums[0]
    
    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)
        
    return max_sum

def maxCrossingSum(nums, left, mid, right):
    left_sum = float('-inf')
    total = 0
    for i in range(mid, left-1, -1):
        total += nums[i]
        if total > left_sum:
            left_sum = total
            
    right_sum = float('-inf')
    total = 0
    for i in range(mid + 1, right + 1):
        total += nums[i]
        if total > right_sum:
            right_sum = total
            
    return left_sum + right_sum

def maxSubArrayDivideAndConquer(nums, left, right):
    if left == right:
        return nums[left]
    
    mid = (left + right) // 2
    
    left_max = maxSubArrayDivideAndConquer(nums, left, mid)
    right_max = maxSubArrayDivideAndConquer(nums, mid + 1, right)
    cross_max = maxCrossingSum(nums, left, mid, right)
    
    return max(left_max, right_max, cross_max)

def maxSubArrayDivideAndConquerWrapper(nums):
    return maxSubArrayDivideAndConquer(nums, 0, len(nums) - 1)

# Test with example input
nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print(""Kadane's Algorithm:"", maxSubArrayKadane(nums))  # Output: 6
print(""Divide and Conquer:"", maxSubArrayDivideAndConquerWrapper(nums))  # Output: 6","def maxSubArray(nums):
    max_sum = nums[0]
    current_sum = nums[0]

    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)

    return max_sum   nums = [-2,1,-3,4,-1,2,1,-5,4]
print(maxSubArray(nums))  # Output: 6                 nums = [1]
print(maxSubArray(nums))  # Output: 1                    nums = [5,4,-1,7,8]
print(maxSubArray(nums))  # Output: 23",easy
38,"The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:
`""123""`
`""132""`
`""213""`
`""231""`
`""312""`
`""321""`
Given `n` and `k`, return the `kth` permutation sequence.


Example 1:
Input: n = 3, k = 3
Output: ""213""

Example 2:
Input: n = 4, k = 9
Output: ""2314""

Example 3:
Input: n = 3, k = 1
Output: ""123""

Constraints:
`1 <= n <= 9`
`1 <= k <= n!`",,"def getPermutation(n: int, k: int) -> str:
    from math import factorial
    
    # Initialize the list of numbers to get the permutations from
    numbers = list(range(1, n + 1))
    # Convert k to zero-indexed
    k -= 1
    permutation = []
    
    # Iterate to find each digit of the k-th permutation
    for i in range(n, 0, -1):
        fact = factorial(i - 1)
        index = k // fact
        k %= fact
        # Append the number at the index and remove it from the list
        permutation.append(numbers.pop(index))
    
    return ''.join(map(str, permutation))

# Example 1
n1, k1 = 3, 3
result1 = getPermutation(n1, k1)
print(f""Example 1: n = {n1}, k = {k1} => Permutation: {result1}"")

# Example 2
n2, k2 = 4, 9
result2 = getPermutation(n2, k2)
print(f""Example 2: n = {n2}, k = {k2} => Permutation: {result2}"")

# Example 3
n3, k3 = 3, 1
result3 = getPermutation(n3, k3)
print(f""Example 3: n = {n3}, k = {k3} => Permutation: {result3}"")","from math import factorial

def getPermutation(n, k):
    numbers = list(range(1, n+1))
    permutation = ''
    k -= 1  # Convert to zero-indexed
    while n > 0:
        n -= 1
        # Determine the index of the next number to add to the permutation
        index, k = divmod(k, factorial(n))
        permutation += str(numbers[index])
        # Remove used number from the list
        numbers.pop(index)
    return permutation

# Example usage:
print(getPermutation(3, 3))  # Output: ""213""
print(getPermutation(4, 9))  # Output: ""2314""
print(getPermutation(3, 1))  # Output: ""123""",medium
39,"Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:
A word is defined as a character sequence consisting of non-space characters only.

Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.

The input array `words` contains at least one word.


Example 1:
Input: words = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""], maxWidth = 16
Output:
[
   ""This    is    an"",
   ""example  of text"",
   ""justification.  ""
]

Example 2:
Input: words = [""What"",""must"",""be"",""acknowledgment"",""shall"",""be""], maxWidth = 16
Output:
[
  ""What   must   be"",
  ""acknowledgment  "",
  ""shall be        ""
]
Explanation: Note that the last line is ""shall be    "" instead of ""shall     be"", because the last line must be left-justified instead of fully-justified.

Note that the second line is also left-justified becase it contains only one word.


Example 3:
Input: words = [""Science"",""is"",""what"",""we"",""understand"",""well"",""enough"",""to"",""explain"",""to"",""a"",""computer."",""Art"",""is"",""everything"",""else"",""we"",""do""], maxWidth = 20
Output:
[
  ""Science  is  what we"",
  ""understand      well"",
  ""enough to explain to"",
  ""a  computer.  Art is"",
  ""everything  else  we"",
  ""do                  ""
]

Constraints:
`1 <= words.length <= 300`
`1 <= words[i].length <= 20`
`words[i]` consists of only English letters and symbols.

`1 <= maxWidth <= 100`
`words[i].length <= maxWidth`",,"def full_justify(words, maxWidth):
    result = []
    n = len(words)
    i = 0
    
    while i < n:
        # Determine the start and end of the current line
        line_length = 0
        line_words = []
        
        while i < n and line_length + len(words[i]) + len(line_words) <= maxWidth:
            line_words.append(words[i])
            line_length += len(words[i])
            i += 1
        
        # Calculate the number of spaces to distribute
        total_spaces = maxWidth - line_length
        number_of_slots = len(line_words) - 1
        
        if number_of_slots == 0 or i == n:
            # Left justify (last line or line with a single word)
            line = ' '.join(line_words)
            line += ' ' * (maxWidth - len(line))
        else:
            # Full justify
            spaces = [total_spaces // number_of_slots] * number_of_slots
            for j in range(total_spaces % number_of_slots):
                spaces[j] += 1
            
            line = ''
            for k in range(len(line_words) - 1):
                line += line_words[k] + ' ' * spaces[k]
            line += line_words[-1]
        
        result.append(line)
    
    return result

# Example 1
words1 = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
maxWidth1 = 16
print(full_justify(words1, maxWidth1))

# Example 2
words2 = [""What"", ""must"", ""be"", ""acknowledgment"", ""shall"", ""be""]
maxWidth2 = 16
print(full_justify(words2, maxWidth2))

# Example 3
words3 = [""Science"", ""is"", ""what"", ""we"", ""understand"", ""well"", ""enough"", ""to"", ""explain"", ""to"", ""a"", ""computer."", ""Art"", ""is"", ""everything"", ""else"", ""we"", ""do""]
maxWidth3 = 20
print(full_justify(words3, maxWidth3))","def full_justify(words, maxWidth):
    result = []
    line = []
    line_length = 0

    for word in words:
        if line_length + len(word) + len(line) > maxWidth:
            # Distribute spaces evenly between words
            spaces_needed = maxWidth - line_length
            num_words = len(line)
            if num_words == 1:
                # For a single word, left-justify
                result.append(line[0] + ' ' * spaces_needed)
            else:
                # For multiple words, distribute spaces
                spaces_per_word, extra_spaces = divmod(spaces_needed, num_words - 1)
                line_str = ''
                for i, w in enumerate(line):
                    line_str += w
                    if i < num_words - 1:
                        line_str += ' ' * (spaces_per_word + (i < extra_spaces))
                result.append(line_str)

            line = []
            line_length = 0

        line.append(word)
        line_length += len(word)

    # Left-justify the last line
    result.append(' '.join(line).ljust(maxWidth))

    return result

# Example usage
words1 = [""This"", ""is"", ""an"", ""example"", ""of"", ""text"", ""justification.""]
maxWidth1 = 16
output1 = full_justify(words1, maxWidth1)
print(output1)

words2 = [""What"", ""must"", ""be"", ""acknowledgment"", ""shall"", ""be""]
maxWidth2 = 16
output2 = full_justify(words2, maxWidth2)
print(output2)",medium
40,"Given two integers `tomatoSlices` and `cheeseSlices`. The ingredients of different burgers are as follows:
Jumbo Burger: 4 tomato slices and 1 cheese slice.

Small Burger: 2 Tomato slices and 1 cheese slice.

Return `[total_jumbo, total_small]` so that the number of remaining `tomatoSlices` equal to 0 and the number of remaining `cheeseSlices` equal to 0. If it is not possible to make the remaining `tomatoSlices` and `cheeseSlices` equal to 0 return `[]`.


Example 1:
Input: tomatoSlices = 16, cheeseSlices = 7
Output: [1,6]
Explantion: To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese. There will be no remaining ingredients.


Example 2:
Input: tomatoSlices = 17, cheeseSlices = 4
Output: []
Explantion: There will be no way to use all ingredients to make small and jumbo burgers.


Example 3:
Input: tomatoSlices = 4, cheeseSlices = 17
Output: []
Explantion: Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.


Example 4:
Input: tomatoSlices = 0, cheeseSlices = 0
Output: [0,0]

Example 5:
Input: tomatoSlices = 2, cheeseSlices = 1
Output: [0,1]

Constraints:
`0 <= tomatoSlices <= 10^7`
`0 <= cheeseSlices <= 10^7`",,"def numOfBurgers(tomatoSlices, cheeseSlices):
    # Check if it is possible for J and S to be integers and non-negative
    if (tomatoSlices - 2 * cheeseSlices) % 2 != 0:
        return []
    
    J = (tomatoSlices - 2 * cheeseSlices) // 2
    S = cheeseSlices - J
    
    # Check if the values are non-negative
    if J < 0 or S < 0:
        return []
    
    return [J, S]

# Test cases
print(numOfBurgers(16, 7))  # Output: [1, 6]
print(numOfBurgers(17, 4))  # Output: []
print(numOfBurgers(4, 17))  # Output: []
print(numOfBurgers(0, 0))   # Output: [0, 0]
print(numOfBurgers(2, 1))   # Output: [0, 1]","def numOfBurgers(tomatoSlices, cheeseSlices):
    # Calculate the number of Jumbo Burgers and Small Burgers
    jumbo = (tomatoSlices - 2 * cheeseSlices) // 2
    small = (4 * cheeseSlices - tomatoSlices) // 2
    
    # Check if both values are non-negative integers
    if jumbo >= 0 and small >= 0:
        return [jumbo, small]
    else:
        return []",medium
